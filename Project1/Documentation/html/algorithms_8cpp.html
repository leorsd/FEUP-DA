<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DA2025_PRJ1_T04G02: SourceCode/Algorithms/algorithms.cpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">DA2025_PRJ1_T04G02
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_ec5974339a1de2ed9600da4dc21f3a8e.html">SourceCode</a></li><li class="navelem"><a class="el" href="dir_6996d7c2da31c87b6af046372cf1d272.html">Algorithms</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">algorithms.cpp File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Implementation of the algorithms declared in <a class="el" href="algorithms_8h.html" title="Function declarations for the algorithms used in the project.">algorithms.h</a>.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="algorithms_8h_source.html">algorithms.h</a>&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for algorithms.cpp:</div>
<div class="dyncontent">
<div class="center"><img src="algorithms_8cpp__incl.png" border="0" usemap="#aSourceCode_2Algorithms_2algorithms_8cpp" alt=""/></div>
</div>
</div>
<p><a href="algorithms_8cpp_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aa05b52738e986633b46833b89252a962" id="r_aa05b52738e986633b46833b89252a962"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="algorithms_8cpp.html#aa05b52738e986633b46833b89252a962">relaxDriving</a> (<a class="el" href="classEdge.html">Edge</a> *edge)</td></tr>
<tr class="memdesc:aa05b52738e986633b46833b89252a962"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function relaxDriving is used to relax the edges of the graph for the driving algorithm.  <br /></td></tr>
<tr class="separator:aa05b52738e986633b46833b89252a962"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa53dd0c320ae76e3bcf634a8b060dde8" id="r_aa53dd0c320ae76e3bcf634a8b060dde8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="algorithms_8cpp.html#aa53dd0c320ae76e3bcf634a8b060dde8">relaxWalking</a> (<a class="el" href="classEdge.html">Edge</a> *edge)</td></tr>
<tr class="memdesc:aa53dd0c320ae76e3bcf634a8b060dde8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function relaxWalking is used to relax the edges of the graph for the walking algorithm.  <br /></td></tr>
<tr class="separator:aa53dd0c320ae76e3bcf634a8b060dde8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed82a366bd18de5797597a98dab7d614" id="r_aed82a366bd18de5797597a98dab7d614"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="algorithms_8cpp.html#aed82a366bd18de5797597a98dab7d614">dijkstraDriving</a> (<a class="el" href="classGraph.html">Graph</a> *g, <a class="el" href="classVertex.html">Vertex</a> *sourceNode, <a class="el" href="classVertex.html">Vertex</a> *destNode)</td></tr>
<tr class="memdesc:aed82a366bd18de5797597a98dab7d614"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function dijkstraDriving is used to calculate the shortest path for driving from the source node to the destination node or to all nodes if the destNode is nullptr.  <br /></td></tr>
<tr class="separator:aed82a366bd18de5797597a98dab7d614"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae21c740f3fd2eba3f9bca9ee00ee7e3b" id="r_ae21c740f3fd2eba3f9bca9ee00ee7e3b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="algorithms_8cpp.html#ae21c740f3fd2eba3f9bca9ee00ee7e3b">dijkstraWalking</a> (<a class="el" href="classGraph.html">Graph</a> *g, <a class="el" href="classVertex.html">Vertex</a> *sourceNode, <a class="el" href="classVertex.html">Vertex</a> *destNode)</td></tr>
<tr class="memdesc:ae21c740f3fd2eba3f9bca9ee00ee7e3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function dijkstraWalking is used to calculate the shortest path for walking from the source node to the destination node or to all nodes if the destNode is nullptr.  <br /></td></tr>
<tr class="separator:ae21c740f3fd2eba3f9bca9ee00ee7e3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee1b106dfdabb7647164fd7dac79caab" id="r_aee1b106dfdabb7647164fd7dac79caab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="algorithms_8cpp.html#aee1b106dfdabb7647164fd7dac79caab">independentRoute</a> (<a class="el" href="classGraph.html">Graph</a> *graph, <a class="el" href="classVertex.html">Vertex</a> *sourceNode, <a class="el" href="classVertex.html">Vertex</a> *destNode, std::list&lt; int &gt; *bestRoute, int *bestRouteTime, std::list&lt; int &gt; *alternativeRoute, int *alternativeRouteTime)</td></tr>
<tr class="memdesc:aee1b106dfdabb7647164fd7dac79caab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the algorithm to compute the best route from the source node to the destination node and an alternative route that not includes the same nodes.  <br /></td></tr>
<tr class="separator:aee1b106dfdabb7647164fd7dac79caab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adefb10bdaebdb71be8b81ce3e1d667a7" id="r_adefb10bdaebdb71be8b81ce3e1d667a7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="algorithms_8cpp.html#adefb10bdaebdb71be8b81ce3e1d667a7">restrictedRoute</a> (<a class="el" href="classGraph.html">Graph</a> *graph, <a class="el" href="classVertex.html">Vertex</a> *sourceNode, <a class="el" href="classVertex.html">Vertex</a> *destNode, <a class="el" href="classVertex.html">Vertex</a> *<a class="el" href="batch_8cpp.html#a9d42491c8ffa716c85a747b3500dae85">includeNode</a>, std::list&lt; int &gt; *restrictedRoute, int *restrictedRouteTime)</td></tr>
<tr class="memdesc:adefb10bdaebdb71be8b81ce3e1d667a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the algorithm to compute the best route from the source node to the destination node, with the provided restrictions.  <br /></td></tr>
<tr class="separator:adefb10bdaebdb71be8b81ce3e1d667a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac69697073d682ab0765406126e980634" id="r_ac69697073d682ab0765406126e980634"><td class="memItemLeft" align="right" valign="top"><a class="el" href="algorithms_8h.html#ae682b37485bf37555dc690063927fd52">RouteResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="algorithms_8cpp.html#ac69697073d682ab0765406126e980634">bestRouteDrivingWalking</a> (<a class="el" href="classGraph.html">Graph</a> *graph, <a class="el" href="classVertex.html">Vertex</a> *sourceNode, <a class="el" href="classVertex.html">Vertex</a> *destNode, int maxWalkTime, std::list&lt; int &gt; *drivingRoute, int *drivingTime, std::list&lt; int &gt; *walkingRoute, int *walkingTime)</td></tr>
<tr class="memdesc:ac69697073d682ab0765406126e980634"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the algorithm to compute the best route from the source node to the destination node, including a driving segment, a parking node and a walking segment.  <br /></td></tr>
<tr class="separator:ac69697073d682ab0765406126e980634"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a014ec703e4996c0751580ebd19c4b19c" id="r_a014ec703e4996c0751580ebd19c4b19c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="algorithms_8cpp.html#a014ec703e4996c0751580ebd19c4b19c">aproximateSolution</a> (<a class="el" href="classGraph.html">Graph</a> *graph, <a class="el" href="classVertex.html">Vertex</a> *sourceNode, <a class="el" href="classVertex.html">Vertex</a> *destNode, std::list&lt; int &gt; *drivingRoute1, int *drivingTime1, std::list&lt; int &gt; *walkingRoute1, int *walkingTime1, std::list&lt; int &gt; *drivingRoute2, int *drivingTime2, std::list&lt; int &gt; *walkingRoute2, int *walkingTime2)</td></tr>
<tr class="memdesc:a014ec703e4996c0751580ebd19c4b19c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the algorithm to compute the best aproximate solution after the failing of the best route with driving and walking segments.  <br /></td></tr>
<tr class="separator:a014ec703e4996c0751580ebd19c4b19c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Implementation of the algorithms declared in <a class="el" href="algorithms_8h.html" title="Function declarations for the algorithms used in the project.">algorithms.h</a>. </p>

<p class="definition">Definition in file <a class="el" href="algorithms_8cpp_source.html">algorithms.cpp</a>.</p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a014ec703e4996c0751580ebd19c4b19c" name="a014ec703e4996c0751580ebd19c4b19c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a014ec703e4996c0751580ebd19c4b19c">&#9670;&#160;</a></span>aproximateSolution()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void aproximateSolution </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGraph.html">Graph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>sourceNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>destNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::list&lt; int &gt; *&#160;</td>
          <td class="paramname"><em>drivingRoute1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>drivingTime1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::list&lt; int &gt; *&#160;</td>
          <td class="paramname"><em>walkingRoute1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>walkingTime1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::list&lt; int &gt; *&#160;</td>
          <td class="paramname"><em>drivingRoute2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>drivingTime2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::list&lt; int &gt; *&#160;</td>
          <td class="paramname"><em>walkingRoute2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>walkingTime2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes the algorithm to compute the best aproximate solution after the failing of the best route with driving and walking segments. </p>
<p>The algorithm is similar to the bestRouteDrivingWalking algorithm. The only differente is in the computation of the best combination of driving and walking segments. The algorithm will compute the best combination of driving and walking segments, but this time, the algorithm will not check if the time of the walking segment is less than the maximum time allowed for walking. This way, the best combinations found will have the less time of driving and walking segments, but the time of the walking segment can be greater than the maximum time allowed for walking.</p>
<p>The asymptotic comlexity of this algorithm is exacty the same as the bestRouteDrivingWalking algorithm, as the only difference in the computation of the best combination does not affect the complexity of the algorithm.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>The graph to be used. </td></tr>
    <tr><td class="paramname">sourceNode</td><td>The source node. </td></tr>
    <tr><td class="paramname">destNode</td><td>The destination node. </td></tr>
    <tr><td class="paramname">drivingRoute1</td><td>The list where the nodes resulting from the best driving segment will be stored. </td></tr>
    <tr><td class="paramname">drivingTime1</td><td>The time of the best driving segment. </td></tr>
    <tr><td class="paramname">walkingRoute1</td><td>The list where the nodes resulting from the best walking segment will be stored. </td></tr>
    <tr><td class="paramname">walkingTime1</td><td>The time of the best walking segment. </td></tr>
    <tr><td class="paramname">drivingRoute2</td><td>The list where the nodes resulting from the second best driving segment will be stored. </td></tr>
    <tr><td class="paramname">drivingTime2</td><td>The time of the second best driving segment. </td></tr>
    <tr><td class="paramname">walkingRoute2</td><td>The list where the nodes resulting from the second best walking segment will be stored. </td></tr>
    <tr><td class="paramname">walkingTime2</td><td>The time of the second best walking segment.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

<p class="definition">Definition at line <a class="el" href="algorithms_8cpp_source.html#l00277">277</a> of file <a class="el" href="algorithms_8cpp_source.html">algorithms.cpp</a>.</p>

</div>
</div>
<a id="ac69697073d682ab0765406126e980634" name="ac69697073d682ab0765406126e980634"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac69697073d682ab0765406126e980634">&#9670;&#160;</a></span>bestRouteDrivingWalking()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="algorithms_8h.html#ae682b37485bf37555dc690063927fd52">RouteResult</a> bestRouteDrivingWalking </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGraph.html">Graph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>sourceNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>destNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxWalkTime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::list&lt; int &gt; *&#160;</td>
          <td class="paramname"><em>drivingRoute</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>drivingTime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::list&lt; int &gt; *&#160;</td>
          <td class="paramname"><em>walkingRoute</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>walkingTime</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes the algorithm to compute the best route from the source node to the destination node, including a driving segment, a parking node and a walking segment. </p>
<p>The algorithm is divided in 3 parts:</p><ol type="1">
<li>Compute the shortest path from the source node to all the parking nodes. It is used 1 Dijkstra's algorithm to compute all the shortest paths from the source node to all the parking nodes. This paths are stored in a list.</li>
<li>Compute the shortest path from all the parking nodes to the destination node. It is used 1 Dijkstra's algorithm to compute all the shortest paths from all the parking nodes to the destination node. This paths are stored in a list.</li>
<li>The best combination of the driving paths and walking paths is done, garanting that the time of the walking path is less than the maximum time allowed for walking and the end of the driving segments is the same as the start of the walking segment. The best combination is the one that has the minimum time of driving and walking.</li>
</ol>
<p>The asymptotic comlexity of this algorithm is easily divided in 2 parts, the Dijkstra's algorithm for the driving or the walking segment and the computation of the best combination of driving and walking segments. The complexity of the Dijkstra's algorithm is O((V + E) log V), where V is the number of vertices and E is the number of edges. The complexity of the combination of driving and walking segments is O(n^2), where n is the number of parking nodes, that in the worst case is V. So, in the worst case, the complexity of the algorithm is dominated by the dijkstra's algorithm, which is O((V + E) log V), where E can be V^2. So in the worst case, the complexity is O(V^2 log V). In case of sparse graphs, the dijkstra's algorithm can be (V log V), when the number of edges is less than V^2. In this scenario, the complexity of the algorithm is dominated by the combination of driving and walking segments, which is O(n^2), where n is the number of parking nodes and in the worst case, n is V. In the end, in the worst cases, the complexity of the algorithm is O(V² log V) for dense graphs and O(V²) for sparse graphs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>The graph to be used. </td></tr>
    <tr><td class="paramname">sourceNode</td><td>The source node. </td></tr>
    <tr><td class="paramname">destNode</td><td>The destination node. </td></tr>
    <tr><td class="paramname">maxWalkTime</td><td>The maximum time allowed for walking. </td></tr>
    <tr><td class="paramname">drivingRoute</td><td>The list where the nodes resulting from the best route will be stored. </td></tr>
    <tr><td class="paramname">drivingTime</td><td>The time of the best route. </td></tr>
    <tr><td class="paramname">walkingRoute</td><td>The list where the nodes resulting from the best route will be stored. </td></tr>
    <tr><td class="paramname">walkingTime</td><td>The time of the best route.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RouteResult The result of the route calculation, that is used to determine if an aproximate solution is possible or not. </dd></dl>

<p class="definition">Definition at line <a class="el" href="algorithms_8cpp_source.html#l00182">182</a> of file <a class="el" href="algorithms_8cpp_source.html">algorithms.cpp</a>.</p>

</div>
</div>
<a id="aed82a366bd18de5797597a98dab7d614" name="aed82a366bd18de5797597a98dab7d614"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed82a366bd18de5797597a98dab7d614">&#9670;&#160;</a></span>dijkstraDriving()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dijkstraDriving </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGraph.html">Graph</a> *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>sourceNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>destNode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function dijkstraDriving is used to calculate the shortest path for driving from the source node to the destination node or to all nodes if the destNode is nullptr. </p>
<p>The algorithm is done to ignore the nodes or the edges that have the avoid flag set to true, so this nodes and edges will not be included in the route. This is useful to avoid nodes that are not allowed to be used in the route, for example, nodes that need to be avoided due to the user restrictions or the nodes that were used for the best route and need to be avoided for the alternative route. Asymptotic complexity: O( (V + E) log V) where E is the number of edges and V is the number of vertices.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>The graph to be used. </td></tr>
    <tr><td class="paramname">sourceNode</td><td>The source node. </td></tr>
    <tr><td class="paramname">destNode</td><td>The destination node. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="algorithms_8cpp_source.html#l00032">32</a> of file <a class="el" href="algorithms_8cpp_source.html">algorithms.cpp</a>.</p>

</div>
</div>
<a id="ae21c740f3fd2eba3f9bca9ee00ee7e3b" name="ae21c740f3fd2eba3f9bca9ee00ee7e3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae21c740f3fd2eba3f9bca9ee00ee7e3b">&#9670;&#160;</a></span>dijkstraWalking()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dijkstraWalking </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGraph.html">Graph</a> *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>sourceNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>destNode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function dijkstraWalking is used to calculate the shortest path for walking from the source node to the destination node or to all nodes if the destNode is nullptr. </p>
<p>The algorithm is done to ignore the nodes or the edges that have the avoid flag set to true, so this nodes and edges will not be included in the route. This is useful to avoid nodes that are not allowed to be used in the route, for example, nodes that need to be avoided due to the user restrictions or the nodes that were used for the best route and need to be avoided for the alternative route. Asymptotic complexity: O( (V + E) log V) where E is the number of edges and V is the number of vertices.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>The graph to be used. </td></tr>
    <tr><td class="paramname">sourceNode</td><td>The source node. </td></tr>
    <tr><td class="paramname">destNode</td><td>The destination node. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="algorithms_8cpp_source.html#l00060">60</a> of file <a class="el" href="algorithms_8cpp_source.html">algorithms.cpp</a>.</p>

</div>
</div>
<a id="aee1b106dfdabb7647164fd7dac79caab" name="aee1b106dfdabb7647164fd7dac79caab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee1b106dfdabb7647164fd7dac79caab">&#9670;&#160;</a></span>independentRoute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void independentRoute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGraph.html">Graph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>sourceNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>destNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::list&lt; int &gt; *&#160;</td>
          <td class="paramname"><em>bestRoute</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>bestRouteTime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::list&lt; int &gt; *&#160;</td>
          <td class="paramname"><em>alternativeRoute</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>alternativeRouteTime</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes the algorithm to compute the best route from the source node to the destination node and an alternative route that not includes the same nodes. </p>
<p>The algorithm uses Dijkstra's algorithm to compute the shortest path from the source node to the destination node, for each one of the nodes that are in the best route, the avoid flag is set to true and the Dijkstra's algorithm is executed again to compute the alternative route.</p>
<p>The asymptotic complexity of the algorithm is set by the Dijkstra's algorithm for shortest paths, which is O((V + E) log V), where V is the number of vertices and E is the number of edges.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>The graph to be used. </td></tr>
    <tr><td class="paramname">sourceNode</td><td>The source node. </td></tr>
    <tr><td class="paramname">destNode</td><td>The destination node. </td></tr>
    <tr><td class="paramname">bestRoute</td><td>The list where the nodes resulting from the best route will be stored. </td></tr>
    <tr><td class="paramname">bestRouteTime</td><td>The time of the best route. </td></tr>
    <tr><td class="paramname">alternativeRoute</td><td>The list where the nodes resulting from the alternative route will be stored. </td></tr>
    <tr><td class="paramname">alternativeRouteTime</td><td>The time of the alternative route.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

<p class="definition">Definition at line <a class="el" href="algorithms_8cpp_source.html#l00088">88</a> of file <a class="el" href="algorithms_8cpp_source.html">algorithms.cpp</a>.</p>

</div>
</div>
<a id="aa05b52738e986633b46833b89252a962" name="aa05b52738e986633b46833b89252a962"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa05b52738e986633b46833b89252a962">&#9670;&#160;</a></span>relaxDriving()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool relaxDriving </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEdge.html">Edge</a> *&#160;</td>
          <td class="paramname"><em>edge</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function relaxDriving is used to relax the edges of the graph for the driving algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">edge</td><td>The edge to be relaxed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the edge was relaxed, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="algorithms_8cpp_source.html#l00008">8</a> of file <a class="el" href="algorithms_8cpp_source.html">algorithms.cpp</a>.</p>

</div>
</div>
<a id="aa53dd0c320ae76e3bcf634a8b060dde8" name="aa53dd0c320ae76e3bcf634a8b060dde8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa53dd0c320ae76e3bcf634a8b060dde8">&#9670;&#160;</a></span>relaxWalking()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool relaxWalking </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEdge.html">Edge</a> *&#160;</td>
          <td class="paramname"><em>edge</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function relaxWalking is used to relax the edges of the graph for the walking algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">edge</td><td>The edge to be relaxed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the edge was relaxed, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="algorithms_8cpp_source.html#l00020">20</a> of file <a class="el" href="algorithms_8cpp_source.html">algorithms.cpp</a>.</p>

</div>
</div>
<a id="adefb10bdaebdb71be8b81ce3e1d667a7" name="adefb10bdaebdb71be8b81ce3e1d667a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adefb10bdaebdb71be8b81ce3e1d667a7">&#9670;&#160;</a></span>restrictedRoute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void restrictedRoute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGraph.html">Graph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>sourceNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>destNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>includeNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::list&lt; int &gt; *&#160;</td>
          <td class="paramname"><em>restrictedRoute</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>restrictedRouteTime</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes the algorithm to compute the best route from the source node to the destination node, with the provided restrictions. </p>
<p>The algorithm uses Dijkstra's algorithm to compute the shortest path from the source node to the destination node excluding the nodes and edges with the avoid flag set to true. In order to include a certain node, the algorithm will compute the shortest path from the source node to the include node and then from the include node to the destination node.</p>
<p>The asymptotic complexity of the algorithm is set by the Dijkstra's algorithm for shortest paths, which is O((V + E) log V), where V is the number of vertices and E is the number of edges.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>The graph to be used. </td></tr>
    <tr><td class="paramname">sourceNode</td><td>The source node. </td></tr>
    <tr><td class="paramname">destNode</td><td>The destination node. </td></tr>
    <tr><td class="paramname">includeNode</td><td>The node that must be included in the route. </td></tr>
    <tr><td class="paramname">restrictedRoute</td><td>The list where the nodes resulting from the best route will be stored. </td></tr>
    <tr><td class="paramname">restrictedRouteTime</td><td>The time of the best route.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

<p class="definition">Definition at line <a class="el" href="algorithms_8cpp_source.html#l00133">133</a> of file <a class="el" href="algorithms_8cpp_source.html">algorithms.cpp</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
