<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DA2025_PRJ2_T04G2: SourceCode/Algorithms/algorithms.cpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">DA2025_PRJ2_T04G2
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_ec5974339a1de2ed9600da4dc21f3a8e.html">SourceCode</a></li><li class="navelem"><a class="el" href="dir_6996d7c2da31c87b6af046372cf1d272.html">Algorithms</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">algorithms.cpp File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>This file contains the implementations of various algorithms for solving the pallet packing problem declared in <a class="el" href="algorithms_8h.html" title="This file contains the declarations of various algorithms for solving the pallet packing problem.">algorithms.h</a>.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="algorithms_8h.html">algorithms.h</a>&quot;</code><br />
<code>#include &lt;algorithm&gt;</code><br />
<code>#include &lt;chrono&gt;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for algorithms.cpp:</div>
<div class="dyncontent">
<div class="center"><img src="algorithms_8cpp__incl.png" border="0" usemap="#aSourceCode_2Algorithms_2algorithms_8cpp" alt=""/></div>
</div>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a52fef1e7e022a6ffff58a033c7db2397" id="r_a52fef1e7e022a6ffff58a033c7db2397"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="algorithms_8cpp.html#a52fef1e7e022a6ffff58a033c7db2397">bruteForceApproach</a> (<a class="el" href="structTruck.html">Truck</a> &amp;truck, std::vector&lt; <a class="el" href="structPallet.html">Pallet</a> &gt; &amp;pallets, std::vector&lt; bool &gt; &amp;selectedPallets)</td></tr>
<tr class="memdesc:a52fef1e7e022a6ffff58a033c7db2397"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to implement the brute force approach for the pallet packing problem.  <br /></td></tr>
<tr class="separator:a52fef1e7e022a6ffff58a033c7db2397"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cb60355326f576609f56db67045d88e" id="r_a1cb60355326f576609f56db67045d88e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="algorithms_8cpp.html#a1cb60355326f576609f56db67045d88e">backtrackingRecursion</a> (<a class="el" href="structTruck.html">Truck</a> &amp;truck, std::vector&lt; <a class="el" href="structPallet.html">Pallet</a> &gt; &amp;pallets, int index, int currentValue, int currentWeight, int currentCount, int &amp;bestValue, int &amp;bestCount, std::vector&lt; int &gt; &amp;remainValue, std::vector&lt; bool &gt; &amp;currentPallets, std::vector&lt; bool &gt; &amp;bestSelection)</td></tr>
<tr class="separator:a1cb60355326f576609f56db67045d88e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add7ec4c709ae6c31eec98f905bed7bee" id="r_add7ec4c709ae6c31eec98f905bed7bee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="algorithms_8cpp.html#add7ec4c709ae6c31eec98f905bed7bee">backtrackingApproach</a> (<a class="el" href="structTruck.html">Truck</a> &amp;truck, std::vector&lt; <a class="el" href="structPallet.html">Pallet</a> &gt; &amp;pallets, std::vector&lt; bool &gt; &amp;selectedPallets)</td></tr>
<tr class="memdesc:add7ec4c709ae6c31eec98f905bed7bee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to implement the backtracking approach for the pallet packing problem.  <br /></td></tr>
<tr class="separator:add7ec4c709ae6c31eec98f905bed7bee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5aadb7ee5002e65aa5fe62ebe5dd2bb3" id="r_a5aadb7ee5002e65aa5fe62ebe5dd2bb3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="algorithms_8cpp.html#a5aadb7ee5002e65aa5fe62ebe5dd2bb3">greedyApproach</a> (<a class="el" href="structTruck.html">Truck</a> &amp;truck, std::vector&lt; <a class="el" href="structPallet.html">Pallet</a> &gt; &amp;pallets, std::vector&lt; bool &gt; &amp;selectedPallets)</td></tr>
<tr class="memdesc:a5aadb7ee5002e65aa5fe62ebe5dd2bb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to implement the greedy approach for the pallet packing problem.  <br /></td></tr>
<tr class="separator:a5aadb7ee5002e65aa5fe62ebe5dd2bb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15fdc60dce3406b68d9787bf129de724" id="r_a15fdc60dce3406b68d9787bf129de724"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="algorithms_8cpp.html#a15fdc60dce3406b68d9787bf129de724">dynamicProgrammingApproach</a> (<a class="el" href="structTruck.html">Truck</a> &amp;truck, std::vector&lt; <a class="el" href="structPallet.html">Pallet</a> &gt; &amp;pallets, std::vector&lt; bool &gt; &amp;selectedPallets)</td></tr>
<tr class="memdesc:a15fdc60dce3406b68d9787bf129de724"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to implement the dynamic programming approach for the pallet packing problem.  <br /></td></tr>
<tr class="separator:a15fdc60dce3406b68d9787bf129de724"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedbf0aa3d61544e1704f12e586b9dc76" id="r_aedbf0aa3d61544e1704f12e586b9dc76"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="algorithms_8cpp.html#aedbf0aa3d61544e1704f12e586b9dc76">integerLinearProgrammingApproach</a> (<a class="el" href="structTruck.html">Truck</a> &amp;truck, std::vector&lt; <a class="el" href="structPallet.html">Pallet</a> &gt; &amp;pallets, std::vector&lt; bool &gt; &amp;selectedPallets)</td></tr>
<tr class="memdesc:aedbf0aa3d61544e1704f12e586b9dc76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to implement the integer linear programming approach for the pallet packing problem.  <br /></td></tr>
<tr class="separator:aedbf0aa3d61544e1704f12e586b9dc76"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This file contains the implementations of various algorithms for solving the pallet packing problem declared in <a class="el" href="algorithms_8h.html" title="This file contains the declarations of various algorithms for solving the pallet packing problem.">algorithms.h</a>. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="add7ec4c709ae6c31eec98f905bed7bee" name="add7ec4c709ae6c31eec98f905bed7bee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add7ec4c709ae6c31eec98f905bed7bee">&#9670;&#160;</a></span>backtrackingApproach()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void backtrackingApproach </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTruck.html">Truck</a> &amp;&#160;</td>
          <td class="paramname"><em>truck</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structPallet.html">Pallet</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>pallets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>selectedPallets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to implement the backtracking approach for the pallet packing problem. </p>
<p>This function uses a backtracking algorithm to explore the solution space and choosing the best option. It recursively builds combinations of pallets, pruning branches that exceed the truck's weight capacity or that the remaining pallets will not reach the best solution found so far. This approach is more efficient than brute force but still has a time complexity of O(2^n) in the worst case, but in practice, it is almost always way faster than the brute force due to pruning.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">truck</td><td>The truck structure containing truck data. </td></tr>
    <tr><td class="paramname">pallets</td><td>A vector of pallets to be packed. </td></tr>
    <tr><td class="paramname">selectedPallets</td><td>A vector of booleans indicating which pallets are selected. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1cb60355326f576609f56db67045d88e" name="a1cb60355326f576609f56db67045d88e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cb60355326f576609f56db67045d88e">&#9670;&#160;</a></span>backtrackingRecursion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void backtrackingRecursion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTruck.html">Truck</a> &amp;&#160;</td>
          <td class="paramname"><em>truck</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structPallet.html">Pallet</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>pallets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>currentValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>currentWeight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>currentCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>bestValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>bestCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>remainValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>currentPallets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>bestSelection</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a52fef1e7e022a6ffff58a033c7db2397" name="a52fef1e7e022a6ffff58a033c7db2397"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52fef1e7e022a6ffff58a033c7db2397">&#9670;&#160;</a></span>bruteForceApproach()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bruteForceApproach </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTruck.html">Truck</a> &amp;&#160;</td>
          <td class="paramname"><em>truck</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structPallet.html">Pallet</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>pallets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>selectedPallets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to implement the brute force approach for the pallet packing problem. </p>
<p>This function explores all possible combinations of pallets to find the optimal packing solution that maximizes profit while respecting the truck's weight capacity. It uses bit manipulation to generate all subsets of pallets and checks each subset for its total weight and profit. This approach has a time complexity of O(2^n), where n is the number of pallets, making it suitable only for small datasets.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">truck</td><td>The truck structure containing truck data. </td></tr>
    <tr><td class="paramname">pallets</td><td>A vector of pallets to be packed. </td></tr>
    <tr><td class="paramname">selectedPallets</td><td>A vector of booleans indicating which pallets are selected. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a15fdc60dce3406b68d9787bf129de724" name="a15fdc60dce3406b68d9787bf129de724"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15fdc60dce3406b68d9787bf129de724">&#9670;&#160;</a></span>dynamicProgrammingApproach()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dynamicProgrammingApproach </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTruck.html">Truck</a> &amp;&#160;</td>
          <td class="paramname"><em>truck</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structPallet.html">Pallet</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>pallets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>selectedPallets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to implement the dynamic programming approach for the pallet packing problem. </p>
<p>This function uses a dynamic programming table to store the maximum profit for each weight capacity and number of pallets. It builds the solution iteratively, ensuring that each pallet is considered only once. This approach has a time complexity of O(nW), where n is the number of pallets and W is the truck's weight capacity. Even though it looks like a polynomial time complexity, it can still be computationally expensive for cases with a big capacity. The weigth capacity is not related to the number of pallets, so it can be very high even though the number of pallets it's small, leading to a possible high running time for big capacities.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">truck</td><td>The truck structure containing truck data. </td></tr>
    <tr><td class="paramname">pallets</td><td>A vector of pallets to be packed. </td></tr>
    <tr><td class="paramname">selectedPallets</td><td>A vector of booleans indicating which pallets are selected. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5aadb7ee5002e65aa5fe62ebe5dd2bb3" name="a5aadb7ee5002e65aa5fe62ebe5dd2bb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5aadb7ee5002e65aa5fe62ebe5dd2bb3">&#9670;&#160;</a></span>greedyApproach()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void greedyApproach </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTruck.html">Truck</a> &amp;&#160;</td>
          <td class="paramname"><em>truck</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structPallet.html">Pallet</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>pallets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>selectedPallets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to implement the greedy approach for the pallet packing problem. </p>
<p>This function sorts the pallets based on their profit-to-weight ratio and iteratively selects pallets until the truck's weight capacity is reached. This approach is efficient with a time complexity of O(n log n) due to sorting, but it does not guarantee an optimal solution.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">truck</td><td>The truck structure containing truck data. </td></tr>
    <tr><td class="paramname">pallets</td><td>A vector of pallets to be packed. </td></tr>
    <tr><td class="paramname">selectedPallets</td><td>A vector of booleans indicating which pallets are selected. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aedbf0aa3d61544e1704f12e586b9dc76" name="aedbf0aa3d61544e1704f12e586b9dc76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedbf0aa3d61544e1704f12e586b9dc76">&#9670;&#160;</a></span>integerLinearProgrammingApproach()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void integerLinearProgrammingApproach </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTruck.html">Truck</a> &amp;&#160;</td>
          <td class="paramname"><em>truck</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structPallet.html">Pallet</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>pallets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>selectedPallets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to implement the integer linear programming approach for the pallet packing problem. </p>
<p>This function uses an external Python script to solve the pallet packing problem using integer linear programming. It generates an input file with the truck's capacity and pallets' data, runs the solver, and reads the output to determine which pallets are selected. This approach is efficient and can handle larger datasets, but it requires Python and the appropriate libraries to be installed. The time complexity depends on the solver used, but it is generally efficient for practical use cases. The Python script is located in the <code>SolverIlp</code> directory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">truck</td><td>The truck structure containing truck data. </td></tr>
    <tr><td class="paramname">pallets</td><td>A vector of pallets to be packed. </td></tr>
    <tr><td class="paramname">selectedPallets</td><td>A vector of booleans indicating which pallets are selected. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
